name: aliyun-acr-build-deploy

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: aliyun-acr-build-deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  ACR_REGISTRY: ${{ secrets.ALIYUN_ACR_REGISTRY }}
  ACR_NAMESPACE: ${{ secrets.ALIYUN_ACR_NAMESPACE }}
  SPARKX_API_BASE_URL: ${{ secrets.SPARKX_API_BASE_URL }}

jobs:
  build_and_push:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - component: agents
            context: agents
            image: sparkplay-agents
            dockerfile: agents/Dockerfile
          - component: service
            context: service
            image: sparkplay-service
            dockerfile: service/Dockerfile
          - component: web
            context: web
            image: sparkplay-web
            dockerfile: web/Dockerfile
          - component: web-api
            context: .
            image: sparkplay-web-api
            dockerfile: web_api/Dockerfile
          - component: web-admin
            context: web_admin
            image: sparkplay-web-admin
            dockerfile: web_admin/Dockerfile
    steps:
      - uses: actions/checkout@v4

      - uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.GH_SUBMODULES_SSH_PRIVATE_KEY }}

      - name: Clone submodules independently
        shell: bash
        run: |
          set -euo pipefail
          # Remove empty submodule directories if exist
          rm -rf skills agents web service
          # Clone each submodule independently
          git clone https://github.com/anil-wu/skills.git skills
          git clone https://github.com/anil-wu/metai-game-code-agent.git agents
          git clone git@github.com:anil-wu/metai-game-front.git web
          git clone -b feature/login git@github.com:anil-wu/sparkx-service.git service
          git clone git@github.com:anil-wu/sparkx-admin.git web_admin

      - name: Generate web env file
        if: matrix.component == 'web'
        shell: bash
        env:
          SPARKX_API_BASE_URL: ${{ env.SPARKX_API_BASE_URL }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          SESSION_MAX_AGE: ${{ secrets.SESSION_MAX_AGE }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
        run: |
          set -euo pipefail
          TEMPLATE="web/.env.example"
          OUT="web/.env.production"
          if [ ! -f "${TEMPLATE}" ]; then
            echo "Missing template: ${TEMPLATE}" >&2
            exit 1
          fi

          awk \
            -v api="${SPARKX_API_BASE_URL:-}" \
            -v google="${GOOGLE_CLIENT_ID:-}" \
            -v maxage="${SESSION_MAX_AGE:-}" \
            -v secret="${SESSION_SECRET:-}" \
            '
            function emit(key, value, original) {
              if (value != "") {
                print key "=" value;
                seen[key] = 1;
              } else {
                print original;
                seen[key] = 1;
              }
            }

            BEGIN { FS = "=" }

            /^[A-Za-z_][A-Za-z0-9_]*=/ {
              key = $1
              original = $0
              if (key == "SPARKX_API_BASE_URL") { emit(key, api, original); next }
              if (key == "GOOGLE_CLIENT_ID") { emit(key, google, original); next }
              if (key == "SESSION_MAX_AGE") { emit(key, maxage, original); next }
              if (key == "SESSION_SECRET") { emit(key, secret, original); next }
            }

            { print $0 }

            END {
              if (!seen["SESSION_SECRET"] && secret != "") {
                print "SESSION_SECRET=" secret;
              }
            }
            ' "${TEMPLATE}" > "${OUT}"

      - name: Ensure web image ships env file
        if: matrix.component == 'web'
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          from __future__ import annotations

          from pathlib import Path

          dockerfile = Path("web/Dockerfile")
          content = dockerfile.read_text(encoding="utf-8")
          if ".env.production" in content:
            raise SystemExit(0)

          lines = content.splitlines(keepends=True)
          insert_line = 'COPY --from=builder --chown=nextjs:bunjs /app/.env.production ./.env.production\n'

          anchor_indices = [
            i
            for i, line in enumerate(lines)
            if "COPY --from=builder" in line and "/app/.next/static" in line
          ]

          if anchor_indices:
            insert_at = anchor_indices[0] + 1
            lines.insert(insert_at, insert_line)
          else:
            user_indices = [i for i, line in enumerate(lines) if line.strip() == "USER nextjs"]
            if not user_indices:
              raise RuntimeError("Unable to locate insertion point in web/Dockerfile")
            insert_at = user_indices[0]
            lines.insert(insert_at, insert_line)

          dockerfile.write_text("".join(lines), encoding="utf-8")
          PY

      - uses: docker/setup-buildx-action@v3
      - name: Normalize ACR registry
        shell: bash
        run: |
          set -euo pipefail
          ACR_REGISTRY_CLEAN="${ACR_REGISTRY#http://}"
          ACR_REGISTRY_CLEAN="${ACR_REGISTRY_CLEAN#https://}"
          ACR_REGISTRY_CLEAN="${ACR_REGISTRY_CLEAN%/}"
          echo "ACR_REGISTRY=${ACR_REGISTRY_CLEAN}" >> "$GITHUB_ENV"

      - name: Login ACR
        shell: bash
        env:
          ACR_USERNAME: ${{ secrets.ALIYUN_ACR_USERNAME }}
          ACR_PASSWORD: ${{ secrets.ALIYUN_ACR_PASSWORD }}
        run: |
          set -euo pipefail
          if [ -z "${ACR_REGISTRY:-}" ] || [ -z "${ACR_NAMESPACE:-}" ] || [ -z "${ACR_USERNAME:-}" ] || [ -z "${ACR_PASSWORD:-}" ]; then
            echo "Missing required secrets: ALIYUN_ACR_REGISTRY, ALIYUN_ACR_NAMESPACE, ALIYUN_ACR_USERNAME, ALIYUN_ACR_PASSWORD" >&2
            exit 1
          fi
          printf '%s' "${ACR_PASSWORD}" | docker login "${ACR_REGISTRY}" -u "${ACR_USERNAME}" --password-stdin

      - name: Mirror mysql image
        if: matrix.component == 'web'
        shell: bash
        run: |
          set -euo pipefail
          docker pull mysql:8.4
          docker tag mysql:8.4 "${ACR_REGISTRY}/${ACR_NAMESPACE}/mysql:8.4"
          docker push "${ACR_REGISTRY}/${ACR_NAMESPACE}/mysql:8.4"

      - name: Check Dockerfile
        id: check
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "${{ matrix.dockerfile }}" ]; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Get Image Tag
        id: tag
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ matrix.component }}" == "web-api" ]; then
            TAG=$(cd service && git rev-parse HEAD)
            echo "Using service repo hash for web-api: ${TAG}"
          elif [ "${{ matrix.component }}" == "service" ]; then
            TAG=$(cd service && git rev-parse HEAD)
            echo "Using service repo hash: ${TAG}"
          elif [ "${{ matrix.component }}" == "web" ]; then
            TAG=$(cd web && git rev-parse HEAD)
            echo "Using web repo hash: ${TAG}"
          elif [ "${{ matrix.component }}" == "agents" ]; then
            TAG=$(cd agents && git rev-parse HEAD)
            echo "Using agents repo hash: ${TAG}"
          elif [ "${{ matrix.component }}" == "web-admin" ]; then
            TAG=$(cd web_admin && git rev-parse HEAD)
            echo "Using web-admin repo hash: ${TAG}"
          else
            TAG="${{ github.sha }}"
          fi
          echo "image_tag=${TAG}" >> "$GITHUB_OUTPUT"

      - name: Build and push
        if: steps.check.outputs.exists == 'true'
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          platforms: linux/amd64
          push: true
          build-args: |
            COMMIT_SHA=${{ steps.tag.outputs.image_tag }}
            OSS_ENDPOINT=${{ secrets.OSS_ENDPOINT }}
            OSS_ACCESS_KEY_ID=${{ secrets.OSS_ACCESS_KEY_ID }}
            OSS_ACCESS_KEY_SECRET=${{ secrets.OSS_ACCESS_KEY_SECRET }}
            OSS_BUCKET=${{ secrets.OSS_BUCKET }}
          tags: |
            ${{ env.ACR_REGISTRY }}/${{ env.ACR_NAMESPACE }}/${{ matrix.image }}:latest
            ${{ env.ACR_REGISTRY }}/${{ env.ACR_NAMESPACE }}/${{ matrix.image }}:${{ steps.tag.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    runs-on: ubuntu-latest
    needs: build_and_push
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    steps:
      - uses: actions/checkout@v4

      - uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.GH_SUBMODULES_SSH_PRIVATE_KEY }}

      - name: Clone submodules independently
        shell: bash
        run: |
          set -euo pipefail
          # Remove empty submodule directories if exist
          rm -rf skills agents web service
          # Clone each submodule independently
          git clone https://github.com/anil-wu/skills.git skills
          git clone https://github.com/anil-wu/metai-game-code-agent.git agents
          git clone git@github.com:anil-wu/metai-game-front.git web
          git clone -b feature/login git@github.com:anil-wu/sparkx-service.git service
          git clone git@github.com:anil-wu/sparkx-admin.git web_admin

      - uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.ALIYUN_DEPLOY_SSH_PRIVATE_KEY }}

      - name: Add known hosts
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          ssh-keyscan -H "${{ secrets.ALIYUN_DEPLOY_HOST }}" >> ~/.ssh/known_hosts

      - name: Deploy
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.ALIYUN_DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.ALIYUN_DEPLOY_USER }}
          DEPLOY_DIR: ${{ secrets.ALIYUN_DEPLOY_DIR }}
          ACR_USERNAME: ${{ secrets.ALIYUN_ACR_USERNAME }}
          ACR_PASSWORD: ${{ secrets.ALIYUN_ACR_PASSWORD }}
          SPARKX_API_BASE_URL: ${{ secrets.SPARKX_API_BASE_URL }}
        run: |
          set -euo pipefail
          if [ -z "${ACR_REGISTRY:-}" ] || [ -z "${ACR_NAMESPACE:-}" ] || [ -z "${ACR_USERNAME:-}" ] || [ -z "${ACR_PASSWORD:-}" ]; then
            echo "Missing required secrets: ALIYUN_ACR_REGISTRY, ALIYUN_ACR_NAMESPACE, ALIYUN_ACR_USERNAME, ALIYUN_ACR_PASSWORD" >&2
            exit 1
          fi
          if [ -z "${DEPLOY_HOST:-}" ] || [ -z "${DEPLOY_USER:-}" ]; then
            echo "Missing required secrets: ALIYUN_DEPLOY_HOST, ALIYUN_DEPLOY_USER" >&2
            exit 1
          fi

          ACR_REGISTRY_CLEAN="${ACR_REGISTRY#http://}"
          ACR_REGISTRY_CLEAN="${ACR_REGISTRY_CLEAN#https://}"
          ACR_REGISTRY_CLEAN="${ACR_REGISTRY_CLEAN%/}"

          # Calculate tags - use latest commit hash from each cloned repo
          WEB_API_TAG=$(cd service && git rev-parse HEAD)
          SERVICE_TAG=$(cd service && git rev-parse HEAD)
          WEB_TAG=$(cd web && git rev-parse HEAD)
          WEB_ADMIN_TAG=$(cd web_admin && git rev-parse HEAD)

          REMOTE_DIR="${DEPLOY_DIR:-sparkx}"
          ssh "${DEPLOY_USER}@${DEPLOY_HOST}" "mkdir -p \"${REMOTE_DIR}\""
          scp ./deploy/docker-compose.yml "${DEPLOY_USER}@${DEPLOY_HOST}:${REMOTE_DIR}/docker-compose.yml"

          ssh "${DEPLOY_USER}@${DEPLOY_HOST}" "bash -s" <<EOF
          set -euo pipefail
          cd "${REMOTE_DIR}"
          if [ ! -f docker-compose.yml ] && [ ! -f docker-compose.yaml ] && [ ! -f compose.yml ] && [ ! -f compose.yaml ]; then
            echo "No compose file found in remote dir: ${REMOTE_DIR}" >&2
            exit 1
          fi
          export ACR_REGISTRY="${ACR_REGISTRY_CLEAN}"
          export ACR_NAMESPACE="${ACR_NAMESPACE}"
          export MYSQL_IMAGE="${ACR_REGISTRY}/${ACR_NAMESPACE}/mysql:8.4"
          export WEB_API_TAG="${WEB_API_TAG}"
          export SERVICE_TAG="${SERVICE_TAG}"
          export WEB_TAG="${WEB_TAG}"
          export WEB_ADMIN_TAG="${WEB_ADMIN_TAG}"
          export SPARKX_API_BASE_URL="${SPARKX_API_BASE_URL}"

          DOCKER_CONFIG_DIR="$(mktemp -d)"
          export DOCKER_CONFIG="\${DOCKER_CONFIG_DIR}"
          trap 'rm -rf "\${DOCKER_CONFIG_DIR}"' EXIT
          printf '%s' "${ACR_PASSWORD}" | docker login "${ACR_REGISTRY}" -u "${ACR_USERNAME}" --password-stdin
          if docker compose version >/dev/null 2>&1; then
            docker compose pull
            docker compose up -d --remove-orphans
          elif command -v docker-compose >/dev/null 2>&1; then
            docker-compose pull
            docker-compose up -d --remove-orphans
          else
            echo "Neither docker compose nor docker-compose is available on remote host" >&2
            exit 1
          fi
          EOF
